-- TURTLE MINER SCRIPT
-- Max's Ultimate Multi-Layer Checkerboard Quarry Bot with Fuel Estimation, Save/Resume, Vein Tracing, and Beacon Detection

-- === SELF-UPDATER ===
local UPDATE_URL = "https://raw.githubusercontent.com/maxajbarlow/minecraft_miner/refs/heads/main/minerMK1.lua"
local SCRIPT_NAME = "startup.lua"

function selfUpdate()
  print("Checking for updates...")
  local response = http.get(UPDATE_URL)
  if not response then
    print("‚ö†Ô∏è Update check failed. Running current version.")
    return
  end

  local remote = response.readAll()
  response.close()

  if fs.exists(SCRIPT_NAME) then
    local current = fs.open(SCRIPT_NAME, "r")
    local localContent = current.readAll()
    current.close()

    if localContent == remote then
      print("‚úÖ No update needed.")
      return
    end
  end

  print("‚¨áÔ∏è New version found. Updating...")
  local file = fs.open(SCRIPT_NAME, "w")
  file.write(remote)
  file.close()
  print("‚úÖ Script updated. Rebooting...")
  os.reboot()
end

if http then selfUpdate() else print("HTTP API is disabled. Skipping auto-update.") end

-- === CONFIGURATION ===
local DEFAULT_X = 100
local DEFAULT_Y = 100
local DEFAULT_LAYERS = 10

local FUEL_SLOT = 1
local CHEST_SLOT = 15
local TORCH_SLOT = 16
local TORCH_SPACING = 9
local SAVE_FILE = "miner_state.txt"

local ENABLE_VEIN_TRACE = true
local VEIN_TRACE_RADIUS = 1

local WHITELIST = {
  ["minecraft:coal_ore"] = true,
  ["minecraft:iron_ore"] = true,
  ["minecraft:gold_ore"] = true,
  ["minecraft:diamond_ore"] = true,
  ["minecraft:redstone_ore"] = true,
  ["minecraft:lapis_ore"] = false,
  ["minecraft:emerald_ore"] = true,
  ["minecraft:copper_ore"] = false,
  ["mekanism:osmium_ore"] = true,
  ["mekanism:lead_ore"] = true,
  ["mekanism:tin_ore"] = true,
  ["mekanism:uranium_ore"] = false,
  ["thermal:tin_ore"] = false,
  ["thermal:silver_ore"] = false,
  ["thermal:lead_ore"] = false,
  ["thermal:nickel_ore"] = false,
  ["create:zinc_ore"] = false,
  ["immersiveengineering:aluminum_ore"] = false
}

-- === STATE ===
local pos = {x = 0, y = 0, z = 0, face = 0}
local currentLayer, currentRow, currentCol = 1, 1, 1
local stepCounter = 0
local surfaceZ = pos.z
local hasteDetected = false

-- === HELPERS ===
function saveState()
  local f = fs.open(SAVE_FILE, "w")
  f.write(textutils.serialize({pos = pos, layer = currentLayer, row = currentRow, col = currentCol}))
  f.close()
end

function loadState()
  if fs.exists(SAVE_FILE) then
    local f = fs.open(SAVE_FILE, "r")
    local data = textutils.unserialize(f.readAll())
    f.close()
    pos = data.pos
    currentLayer = data.layer
    currentRow = data.row
    currentCol = data.col
    return true
  end
  return false
end

function checkBeaconEffect()
  local effects = turtle.getFuelLimit and {} or nil
  if effects then
    for _, e in pairs(effects) do
      if e == "haste" then
        hasteDetected = true
        print("üü° Haste effect detected (Beacon)")
      end
    end
  end
end

function digWithHaste(digFn)
  repeat
    digFn()
    sleep(hasteDetected and 0.05 or 0.2)
  until not digFn()
end

function traceVein(depth)
  if not ENABLE_VEIN_TRACE or (depth or 0) > 10 then return end

  local directions = {
    { inspect = turtle.inspect, dig = turtle.dig },
    { inspect = turtle.inspectUp, dig = turtle.digUp },
    { inspect = turtle.inspectDown, dig = turtle.digDown },
  }

  for _, dir in ipairs(directions) do
    local success, data = dir.inspect()
    if success and isWhitelisted(data.name) then
      digWithHaste(dir.dig)
      traceVein((depth or 0) + 1)
    end
  end
end

function estimateFuel(layerCount, width, height)
  local roundTrip = (width + height) * 2 * 3
  local total = roundTrip * layerCount + 200
  return total
end

-- === MINING FLOW ===

function isWhitelisted(name)
  return WHITELIST[name] == true
end

function faceDirection(dir)
  while pos.face ~= dir do
    turtle.turnRight()
    pos.face = (pos.face + 1) % 4
  end
end

local haltMining = false

function moveForwardSafe()
  if turtle.getFuelLevel() < 10 then
    if not moveForwardSafe.notified then
      print("Low fuel. Returning to surface.")
      moveForwardSafe.notified = true
      returnToSurface()
      haltMining = true
    end
    return
  else
    moveForwardSafe.notified = false
  end
  while not turtle.forward() do turtle.dig() sleep(0.1) end
  if pos.face == 0 then pos.y = pos.y + 1
  elseif pos.face == 1 then pos.x = pos.x + 1
  elseif pos.face == 2 then pos.y = pos.y - 1
  elseif pos.face == 3 then pos.x = pos.x - 1 end
  stepCounter = stepCounter + 1
end

function moveDownSafe()
  while not turtle.down() do turtle.digDown() sleep(0.1) end
  pos.z = pos.z + 1
end

function moveUpSafe()
  while not turtle.up() do turtle.digUp() sleep(0.1) end
  pos.z = pos.z - 1
end

function returnToSurface()
  faceDirection(2)
  while pos.y > 0 do moveForwardSafe() end
  faceDirection(3)
  while pos.x > 0 do moveForwardSafe() end
  while pos.z > surfaceZ do moveUpSafe() end
  faceDirection(2)
  print("Returned to surface.")
  print("üì¶ Turtle has returned to the starting chest position.")
end

function checkAllSides()
  local directions = {
    { inspect = turtle.inspect, dig = turtle.dig },
    { inspect = turtle.inspectUp, dig = turtle.digUp },
    { inspect = turtle.inspectDown, dig = turtle.digDown }
  }
  for _, dir in ipairs(directions) do
    local success, data = dir.inspect()
    if success and isWhitelisted(data.name) then
      digWithHaste(dir.dig)
      if ENABLE_VEIN_TRACE then traceVein() end
    end
  end
end

function mineLayer()
  if haltMining then return end
  for y = 1, DEFAULT_Y do
    local direction = (y % 2 == 1) and 1 or -1
    local startX, endX
    if direction == 1 then
      startX, endX = 1, DEFAULT_X
    else
      startX, endX = DEFAULT_X, 1
    end
    for x = startX, endX, direction do
      currentRow = y
      currentCol = x
      checkAllSides()
      moveForwardSafe()
      saveState()
      if x == endX and y == DEFAULT_Y then
        print("üì¶ Placing chest at end of layer " .. currentLayer .. "...")
        turtle.select(CHEST_SLOT)
        if turtle.placeDown() then
          print("üìÑ Chest placed.")
          for i = 1, 16 do
            if i ~= FUEL_SLOT and i ~= TORCH_SLOT and i ~= CHEST_SLOT then
              turtle.select(i)
              turtle.dropDown()
            end
          end
        else
          print("‚ö†Ô∏è Failed to place chest.")
        end
      end
    end
    if y < DEFAULT_Y then
      if y % 2 == 1 then
        turtle.turnRight()
        moveForwardSafe()
        turtle.turnRight()
      else
        turtle.turnLeft()
        moveForwardSafe()
        turtle.turnLeft()
      end
    end
  end
end

function main()
  if fs.exists(SAVE_FILE) then
    print("A saved session was found. Resume? (y/n)")
    local answer = io.read():lower()
    if answer == "y" then
      if loadState() then
        print("‚úÖ Resumed previous session from layer " .. currentLayer .. ", row " .. currentRow .. ", col " .. currentCol)
      else
        print("‚ö†Ô∏è Failed to load save. Starting fresh.")
      end
    else
      fs.delete(SAVE_FILE)
      print("Save file deleted. Starting fresh.")
    end
  end
  print("Enter depth to start mining (Y-level):")
  local targetY = tonumber(io.read())
  surfaceZ = pos.z
  while pos.z < targetY do moveDownSafe() end
  checkBeaconEffect()
  print("Mining from Y = " .. pos.z)

  local fuelRequired = estimateFuel(DEFAULT_LAYERS, DEFAULT_X, DEFAULT_Y)
  if turtle.getFuelLevel() < fuelRequired then
    print("Not enough fuel. Required: " .. fuelRequired .. ", Available: " .. turtle.getFuelLevel())
    returnToSurface()
    return
  end

  for layer = 1, DEFAULT_LAYERS do
    currentLayer = layer
    print("Starting layer " .. layer .. "...")
    mineLayer()
    if layer < DEFAULT_LAYERS then moveDownSafe() end
  end
  returnToSurface()
end

main()
